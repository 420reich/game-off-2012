/*! FightCode - v0.1.0
* http://fightcodega.me/
*/

var IconPainter;

IconPainter = {
  colorDistance: function(a, b) {
    var c1, c2, da, db, dc, dh, dl, first, lab1, lab2, second, third;
    lab1 = this.XYZToLab(this.RGBToXYZ(a));
    lab2 = this.XYZToLab(this.RGBToXYZ(b));
    c1 = Math.sqrt(lab1[1] * lab1[1] + lab1[2] * lab1[2]);
    c2 = Math.sqrt(lab2[1] * lab2[1] + lab2[2] * lab2[2]);
    dc = c1 - c2;
    dl = lab1[0] - lab2[0];
    da = lab1[1] - lab2[1];
    db = lab1[2] - lab2[2];
    dh = Math.sqrt((da * da) + (db * db) - (dc * dc));
    first = dl;
    second = dc / (1 + 0.045 * c1);
    third = dh / (1 + 0.015 * c1);
    return Math.sqrt(first * first + second * second + third * third);
  },
  RGBToXYZ: function(rgb) {
    var color, i, rgbDec, x, y, z;
    rgbDec = [rgb.r / 255.0, rgb.g / 255.0, rgb.b / 255.0];
    i = 0;
    while (i < 3) {
      color = rgbDec[i];
      if (color > 0.04045) {
        color = (color + 0.055) / 1.055;
        color = Math.pow(color, 2.4);
      } else {
        color = color / 12.92;
      }
      rgbDec[i] = color * 100;
      ++i;
    }
    x = rgbDec[0] * 0.4124 + rgbDec[1] * 0.3576 + rgbDec[2] * 0.1805;
    y = rgbDec[0] * 0.2126 + rgbDec[1] * 0.7152 + rgbDec[2] * 0.0722;
    z = rgbDec[0] * 0.0193 + rgbDec[1] * 0.1192 + rgbDec[2] * 0.9505;
    return [x, y, z];
  },
  XYZToLab: function(xyz) {
    var a, b, color, i, l, xyzAdj;
    xyzAdj = [xyz[0] / 95.047, xyz[1] / 100, xyz[2] / 108.883];
    i = 0;
    while (i < 3) {
      color = xyzAdj[i];
      if (color > 0.008856) {
        color = Math.pow(color, 1 / 3.0);
      } else {
        color = (7.787 * color) + (16 / 116.0);
      }
      xyzAdj[i] = color;
      ++i;
    }
    l = (116 * xyzAdj[1]) - 16;
    a = 500 * (xyzAdj[0] - xyzAdj[1]);
    b = 200 * (xyzAdj[1] - xyzAdj[2]);
    return [l, a, b];
  },
  HexToRGB: function(hex) {
    hex = hex.indexOf("#") > -1 ? hex.substring(1) : hex;
    if (hex.length === 3) {
      hex = hex.split('').reduce(function(a, b) {
        return a + b + b;
      }, '');
    }
    hex = parseInt(hex, 16);
    return {
      r: hex >> 16,
      g: (hex & 0x00FF00) >> 8,
      b: hex & 0x0000FF,
      a: 1
    };
  },
  RGBAStrToRGB: function(rgbaStr) {
    var brokenValue, rgbaValue;
    brokenValue = rgbaStr.replace(/rgba\s*\(([\d\s,.]*)\)/i, "$1").split(",");
    rgbaValue = {
      r: parseInt($.trim(brokenValue[0]), 10),
      g: parseInt($.trim(brokenValue[1]), 10),
      b: parseInt($.trim(brokenValue[2]), 10),
      a: parseFloat($.trim(brokenValue[3]))
    };
    return rgbaValue;
  },
  StrToRGB: function(colorStr) {
    if (colorStr.indexOf("#") >= 0) {
      return this.HexToRGB(colorStr);
    }
    return this.RGBAStrToRGB(colorStr);
  },
  onImageReady: function(img, color, referenceColor, tolerance, callback) {
    var ctx, dist, height, imgData, luminance, pixelData, pos, width, x, y, _i, _j, _ref;
    width = img.width;
    height = img.height;
    ctx = $("<canvas width='" + width + "' height='" + height + "'>")[0].getContext("2d");
    ctx.globalCompositeOperation = "copy";
    ctx.drawImage(img, 0, 0);
    imgData = ctx.getImageData(0, 0, width, height);
    pixelData = imgData.data;
    for (y = _i = 0; 0 <= height ? _i <= height : _i >= height; y = 0 <= height ? ++_i : --_i) {
      for (x = _j = 0, _ref = width * 4; _j <= _ref; x = _j += 4) {
        pos = (y * width * 4) + x;
        dist = this.colorDistance(referenceColor, {
          r: pixelData[pos + 0],
          g: pixelData[pos + 1],
          b: pixelData[pos + 2]
        });
        if (dist < tolerance) {
          luminance = 0.3 * pixelData[pos + 0] + 0.59 * pixelData[pos + 1] + 0.11 * pixelData[pos + 2];
          pixelData[pos + 0] = color.r * (luminance / 127);
          pixelData[pos + 1] = color.g * (luminance / 127);
          pixelData[pos + 2] = color.b * (luminance / 127);
          pixelData[pos + 3] = color.a * pixelData[pos + 3];
        }
      }
    }
    ctx.putImageData(imgData, 0, 0);
    return callback(ctx.canvas.toDataURL());
  },
  paintIcon: function(srcImage, color, referenceColor, tolerance, callback) {
    var img,
      _this = this;
    if (tolerance == null) {
      tolerance = 27;
    }
    if (typeof color === "string") {
      color = this.StrToRGB(color);
    }
    if (typeof srcImage === "string") {
      img = document.createElement('img');
      img.onload = function() {
        return _this.onImageReady(img, color, referenceColor, tolerance, callback);
      };
      return img.src = srcImage;
    } else {
      return this.onImageReady(srcImage, color, referenceColor, tolerance, callback);
    }
  }
};

var Game,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

(function() {
  var targetTime, vendor, w, _i, _len, _ref;
  w = window;
  _ref = ['ms', 'moz', 'webkit', 'o'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    vendor = _ref[_i];
    if (w.requestAnimationFrame) {
      break;
    }
    w.requestAnimationFrame = w["" + vendor + "RequestAnimationFrame"];
    w.cancelAnimationFrame = w["" + vendor + "CancelAnimationFrame"] || w["" + vendor + "CancelRequestAnimationFrame"];
  }
  targetTime = 0;
  w.requestAnimationFrame || (w.requestAnimationFrame = function(callback) {
    var currentTime;
    targetTime = Math.max(targetTime + 16, currentTime = +(new Date));
    return w.setTimeout((function() {
      return callback(+(new Date));
    }), targetTime - currentTime);
  });
  return w.cancelAnimationFrame || (w.cancelAnimationFrame = function(id) {
    return clearTimeout(id);
  });
})();

Game = (function() {

  function Game(board, result, options) {
    this.board = board;
    this.result = result;
    this.options = options;
    this.play = __bind(this.play, this);

    if (this.result) {
      this.events = result.result;
      this.gameEnded = true;
    } else {
      this.events = [];
    }
    this.currentRound = 0;
    this.objects = {};
    this.options = $.extend({
      msPerRound: 100
    }, this.options);
  }

  Game.prototype.start = function() {
    this.lastRound = window.mozAnimationStartTime || Date.now();
    return requestAnimationFrame(this.play);
  };

  Game.prototype.end = function() {
    return this.gameEnded = true;
  };

  Game.prototype.forceEnd = function() {
    this.end();
    return this.events = [];
  };

  Game.prototype.addRound = function(roundLog) {
    return this.events.push(roundLog);
  };

  Game.prototype.createTank = function(object) {
    var color, referenceCannonColor, referenceTankColor, tank, tankObject;
    tank = $('<div class="tank"><div class="body"></div><div class="cannon"></div><div class="life"></div><div class="explosion"></div></div>');
    tankObject = {
      id: object.id,
      name: object.name,
      color: object.color,
      tank: tank,
      body: tank.find('.body'),
      cannon: tank.find('.cannon'),
      life: tank.find('.life')
    };
    referenceTankColor = {
      r: 76,
      g: 168,
      b: 27
    };
    referenceCannonColor = {
      r: 108,
      g: 211,
      b: 42
    };
    color = tankObject.color || '#ff0000';
    IconPainter.paintIcon('/img/tanks.png', color, referenceTankColor, 27, function(dataUrl) {
      return tankObject.body.css('background-image', 'url(' + dataUrl + ')');
    });
    IconPainter.paintIcon('/img/cannon.png', color, referenceCannonColor, 60, function(dataUrl) {
      return tankObject.cannon.css('background-image', 'url(' + dataUrl + ')');
    });
    this.board.append(tank);
    this.objects[object.id] = tankObject;
    return tankObject;
  };

  Game.prototype.createBullet = function(object) {
    var bullet, bulletObject;
    bullet = $('<div class="bullet"><div class="explosion"></div></div>');
    this.board.append(bullet);
    bulletObject = {
      id: object.id,
      bullet: bullet,
      width: bullet.width(),
      height: bullet.height()
    };
    this.objects[object.id] = bulletObject;
    return bulletObject;
  };

  Game.prototype.applyRotate = function(object, angle) {
    return object.style.webkitTransform = object.style.mozTransform = object.style.transform = "rotate3d(0,0,1," + angle + "deg)";
  };

  Game.prototype.handleTank = function(object) {
    var tank;
    tank = this.objects[object.id] || this.createTank(object);
    tank.tank[0].style.top = (object.position.y - (object.dimension.height / 2)) + 'px';
    tank.tank[0].style.left = (object.position.x - (object.dimension.width / 2)) + 'px';
    tank.life[0].style.width = (30 * object.life / 100) + 'px';
    this.applyRotate(tank.body[0], object.angle);
    return this.applyRotate(tank.cannon[0], object.angle + object.cannonAngle);
  };

  Game.prototype.handleBullet = function(object) {
    var bullet;
    bullet = this.objects[object.id];
    bullet.bullet[0].style.top = (object.position.y - (bullet.height / 2)) + 'px';
    bullet.bullet[0].style.left = (object.position.x - (bullet.width / 2)) + 'px';
    return this.applyRotate(bullet.bullet[0], object.angle);
  };

  Game.prototype.removeBullet = function(bulletObject) {
    delete this.objects[bulletObject.id];
    return bulletObject.bullet.remove();
  };

  Game.prototype.play = function(timestamp) {
    var hasFinished, object, onRound, progress, round, roundEvent, roundNumber, rounds, _i, _j, _k, _len, _len1, _ref, _ref1;
    progress = timestamp - this.lastRound;
    rounds = Math.floor(progress / this.options.msPerRound);
    this.lastRound = window.mozAnimationStartTime || Date.now();
    onRound = this.options.onRound;
    for (roundNumber = _i = 0; 0 <= rounds ? _i <= rounds : _i >= rounds; roundNumber = 0 <= rounds ? ++_i : --_i) {
      if (roundNumber + this.currentRound >= this.events.length) {
        break;
      }
      round = this.events[roundNumber + this.currentRound];
      if (onRound) {
        onRound(round);
      }
      _ref = round.objects;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        object = _ref[_j];
        switch (object.type) {
          case 'tank':
            this.handleTank(object);
            break;
          case 'bullet':
            if (!this.objects[object.id]) {
              this.createBullet(object);
            }
            this.handleBullet(object);
        }
      }
      _ref1 = round.events;
      for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
        roundEvent = _ref1[_k];
        object = this.objects[roundEvent.id];
        if (!object) {
          continue;
        }
        switch (roundEvent.type) {
          case 'moving':
            object.tank[0].className = 'tank moving';
            break;
          case 'backwards':
            object.tank[0].className = 'tank moving backwards';
            break;
          case 'stopped':
            object.tank[0].className = 'tank';
            break;
          case 'cloned':
            object.tank[0].className = 'tank cloning';
            break;
          case 'exploded':
            object.bullet[0].className = 'bullet exploding';
            setTimeout(this.removeBullet.bind(this, object), 1000);
            break;
          case 'dead':
            object.tank[0].className = 'tank dead';
            break;
          case 'log':
            console.log.apply(console, ['ROBOT ' + object.name + ':'].concat(roundEvent.messages));
        }
      }
    }
    hasFinished = rounds + this.currentRound >= this.events.length && this.gameEnded;
    if (hasFinished && this.options.onEndGame) {
      this.options.onEndGame(this.result);
    }
    this.currentRound += rounds;
    if (!hasFinished) {
      return requestAnimationFrame(this.play);
    }
  };

  return Game;

})();
